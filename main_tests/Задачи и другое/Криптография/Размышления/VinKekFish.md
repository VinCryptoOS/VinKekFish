Тест на длинну гаммы в режиме Overwrite
Проверить в тесте на то, что 1253539379 даёт длительный прирост (без приращения, с умножением).
Проверить по списку типовых ошибок


# Алгоритм VinKekFish

# Полный шаг губки
Перед первым шагом губки следует первичная инициализация
Она выполняется для губки один раз за всё время её работы.

Затем, для каждого шага следует
1. Вычисление нового Tweak для следующего шага
2. Непосредственный ввод данных
3. Перестановка для распределения впитывания
4. Основной шаг алгоритма
5. Перестановка для объединения данных для вывода
6. Вывод данных


# Первичная инициализация

Первичная инициализация проходит один раз перед началом использования губки.
Дополнительная инициализация ключами или вектором инициализации происходит в шаге алгоритма (подаваемыми на вход губки или в начальный tweak)

## Tweak

Tweak инициализируется нулями либо вектором инициализации. В том числе, инициализация может происходить номером шифруемого блока при древовидном алгоритме шифрования.
Nonce лучше инициализировать непосредственно губку, чтобы обеспечить большую радномизацию.


## Криптграфическое состояние

Криптографическое состояние разделяется на строки по 16-ть байтов.
Далее, для i-ой строки каждого столбца происходит заполнение байта значением (i+1)\*N, где N есть шаг алгоритма для данного столбца.
0  1  2   3   4   5   6   7   8   9  10  11  12  13  14  15
1, 3, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59

Например, для состояния из 32-х байтов состояние будет инициализировано следующими значениями
001 003 007 010 013 017 019 023 029 031 037 041 043 047 053 059 002 006 014 020 026 034 038 046 058 062 074 082 086 094 106 118


# Вычисление нового Tweak для следующего шага

Перед непосредственным вводом данных осуществляется приращение младшего 8-мибайтового слова на значение 1253539379 (это простое число, дано в десятичной системе исчисления).
Старшее 8-мибайтовое слово не изменяется (к нему осуществляется приращение при вводе данных). В том числе, бит переноса из младшего слова в старшее не переносится.

# Непосредственный ввод данных

Ввод данных осуществляется по блокам в 4096 битов (512-ть байтов) и ещё 2 байта вводимого размера в tweak, 2 байта вводимого размера во внутреннее состояние и 1 байта вводимого во внутреннее состояние счётчика режимов.

После вычисления нового Tweak (см. выше), к старшему 8-мибайтному слову добавляется 2 байта размера блока (в байтах) вводимого блока.
Если ввод осуществляется в режиме overwrite, то к старшему байту старшего 8-мибайтового слова добавляется ещё 1 (то есть добавляется 0x0100_0000_0000_0000 к старшему 8-мибайтовому слову).
В режиме губки ничего не добавляется (только размер вводимого блока).

Ввод может осуществляться с операцией побайтового xor (в режиме губки). Первые байты (младшие байты) идут по младшим адресам. Xor осуществляется непосредственно с первыми 512-тью байтами.
Также ввод может осуществляться простой перезаписью байтов (режим overwrite).

padding отсутствует, т.к. в tweak осуществляется ввод размера вводимого блока. В режиме overwrite padding состоит в дополнении сообщения нулями до 512-ти байтов.

Следующие два байта состояния получают xor (всегда именно xor вне зависимости от режима) с количеством вводимых байтов, и ещё следующий байт получает xor со счётчиком режимов.
Счётчик режимов может показывать, что именно происходит. Например, счётчик 1 может показать, что вводится вектор инициализации, счётчик 2 - что вводится ключ, счётчик 0 - что вводятся данные и т.п.
Режим overwrite в данном счётчике никак не обозначается.

## Перестановка для распределения впитывания
Затем выполняется перестановка с помощью таблицы transpose400

## Если ввода не было

Если ввода не было, то, из вышеописанного алгоритма следует следующее.

### В режиме губки
К tweak ничего не приращается (только перерасчёт при начале шага +1253539379), никакие данные не изменяются.

### В режиме overwrite
Все 512-ть первых байтов перезаписываются нулями. Перестановка transpose400 всё равно выполняется. При этом, к tweak идёт приращение 0x0100_0000_0000_0000 к старшему 8-мибайтовому слову (и +1253539379 к младшему 8-мибайтовому слову).


### Ввод данных на следующий шаг не должен зависеть от выхода данных с предыдущего шага

Это важно для того, чтобы злоумышленник не мог воспользоваться выходом дуплекса для того, чтобы его атаковать.
См. стр. 4 "1.3 Our Contribution" "Full-State Keyed Duplex With Built-In Multi-User Support" https://keccak.team/files/FSKD.pdf.

# Вывод

## Перестановка для объединения данных для вывода
После выполнения основного шага алгоритма, выполняется перестановка transpose387.

## Сам вывод
Если нужен вывод, то берутся первые 512-ть байтов состояния (младший байт по младшему адресу).
Перестановка выполняется вне зависимости от того, нужен вывод или нет.

# Основной шаг алгоритма

Основной шаг алгоритма состоит из применения 32-х раундов, состоящих из

0. Вычисление tweakVal
1. Поблочное преобразование keccak
2. Перестановка P1
3. Поблочное преобразование threeFish
4. Перестановка P2
5. Поблочное преобразование keccak
6. Перестановка P3
7. Поблочное преобразование threeFish
8. Переставнока P4.
На последнем раунде вместо P4 используется transpose387 (см. "Перестановка для объединения данных для вывода")

Для P1 используется rnd, кроме первых 8-ми раундов (transpose200)
Для P2 используется rnd, кроме первых 8-ми раундов (transpose256)
P3 - transpose200
P4 - transpose256

Один из P1 или P2 может быть зависим от дополнительного независимого ключа. Предлагается, P1 как зависимый. Независимый ключ - это ключ, который развязан с основным ключом с помощью алгоритма не меньшей стойкости, чем заданный, либо получен полностью независимо (то есть из количества энтропии не меньшего, чем стойкость основного ключа). Независимость ключа следует из того, что перестановки легче перехватывать по побочным каналам, чем простые ключевые вычисления.



Довычисление tweakVal происходит следующим образом.
Работа ведётся с младшим 8-мибайтовым словом tweak (старшее слово не затрагивается, в том числе, бит переноса не переносится).
Старшее 4-хбайтовое слово tweak складывается с номером раунда, домноженным на 2 (tweak не изменяется, запись производится в tweakVal).

Для каждого блока всё (8-мибайтовое) значение складывается с номером блока (начиная с нуля).

Таким образом, на каждый раунд и для каждого блока TweakVal разный.

На второе преобразование threeFish дополнительно старшее 4-хбайтовое слово tweak приращается на единицу.
