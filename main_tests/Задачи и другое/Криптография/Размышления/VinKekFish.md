Тест на длинну гаммы в режиме Overwrite
Проверить в тесте на то, что 1253539379 даёт длительный прирост (без приращения, с умножением).
Проверить по списку типовых ошибок

Сделать статистические тесты (см. в конце)

# Алгоритм VinKekFish

# Полный шаг губки
Перед первым шагом губки следует первичная инициализация
Она выполняется для губки один раз за всё время её работы.

Затем, для каждого шага следует
1. Вычисление нового Tweak для следующего шага
2. Непосредственный ввод данных
3. Перестановка для распределения впитывания
4. Основной шаг алгоритма
5. Перестановка для объединения данных для вывода
6. Вывод данных

# Размер состояния
Размер состояния n*25600,
где n - нечётное натуральное число (1 или более; 1, 3, 5, 7 и т.д.).
Нечётность числа следует из того, что тогда общее количество блоков не делится на два. Допустим, для количества блоков 25 следует, что 0-ой блок соответствует 12-ому блоку. 12-ый блок соответствует 24-ому. 13-ый соответствует 0-ому.
Таким образом, при преобразовании 0-ого блока ключ берётся из 12-ого блока. Но ключ из 0-ого блока берётся для преобразования 13-ого блока. То есть при многократном преобразовании, блоки будут сами собой перемешивать данные даже без таблиц перестановок. Данные не будут зацикливаться только на одной паре блоков.

# Первичная инициализация

Первичная инициализация проходит один раз перед началом использования губки.
Дополнительная инициализация ключами или вектором инициализации происходит в шаге алгоритма (подаваемыми на вход губки или в начальный tweak)

## Tweak

Tweak инициализируется нулями либо вектором инициализации. В том числе, инициализация может происходить номером шифруемого блока при древовидном алгоритме шифрования.
Nonce лучше инициализировать непосредственно губку, чтобы обеспечить большую радномизацию.


## Криптграфическое состояние

Криптографическое состояние разделяется на строки по 16-ть байтов.
Далее, для i-ой строки каждого столбца происходит заполнение байта значением (i+1)\*N, где N есть шаг алгоритма для данного столбца.
0  1  2   3   4   5   6   7   8   9  10  11  12  13  14  15
1, 3, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59

Например, для состояния из 32-х байтов состояние будет инициализировано следующими значениями
001 003 007 010 013 017 019 023 029 031 037 041 043 047 053 059 002 006 014 020 026 034 038 046 058 062 074 082 086 094 106 118


# Вычисление нового Tweak для следующего шага

Перед непосредственным вводом данных осуществляется приращение младшего 8-мибайтового слова на значение 1253539379 (это простое число, дано в десятичной системе исчисления).
Старшее 8-мибайтовое слово не изменяется (к нему осуществляется приращение при вводе данных). В том числе, бит переноса из младшего слова в старшее не переносится.

# Непосредственный ввод данных

Ввод данных осуществляется по блокам в 4096 битов (512-ть байтов) и ещё 2 байта вводимого размера в tweak, 2 байта вводимого размера во внутреннее состояние и 1 байта вводимого во внутреннее состояние счётчика режимов.

После вычисления нового Tweak (см. выше), к старшему 8-мибайтному слову добавляется 2 байта размера блока (в байтах) вводимого блока.
Если ввод осуществляется в режиме overwrite, то к старшему байту старшего 8-мибайтового слова добавляется ещё 1 (то есть добавляется 0x0100_0000_0000_0000 к старшему 8-мибайтовому слову).
В режиме губки ничего не добавляется (только размер вводимого блока).
Кроме этого, в любом из режимов, к 3-ему с конца байту старшего 8-мибайтового слова добавляется значение счётчика режимов.

Ввод может осуществляться с операцией побайтового xor (в режиме губки). Первые байты (младшие байты) идут по младшим адресам. Xor осуществляется непосредственно с первыми 512-тью байтами.
Также ввод может осуществляться простой перезаписью байтов (режим overwrite).

padding отсутствует, т.к. в tweak осуществляется ввод размера вводимого блока. В режиме overwrite padding состоит в дополнении сообщения нулями до 512-ти байтов.

Следующие два байта состояния получают xor (всегда именно xor вне зависимости от режима) с количеством вводимых байтов, и ещё следующий байт получает xor со счётчиком режимов.
Счётчик режимов может показывать, что именно происходит. Например, счётчик 1 может показать, что вводится вектор инициализации, счётчик 2 - что вводится ключ, счётчик 0 - что вводятся данные и т.п.
Режим overwrite в данном счётчике никак не обозначается.

## Перестановка для распределения впитывания
Затем выполняется перестановка с помощью таблицы transpose200

## Если ввода не было

Если ввода не было, то, из вышеописанного алгоритма следует следующее.

### В режиме губки
К tweak ничего не приращается (только перерасчёт при начале шага +1253539379), никакие данные не изменяются.

### В режиме overwrite
Все 512-ть первых байтов перезаписываются нулями. Перестановка transpose200 всё равно выполняется. При этом, к tweak идёт приращение 0x0100_0000_0000_0000 к старшему 8-мибайтовому слову (и +1253539379 к младшему 8-мибайтовому слову).


### Ввод данных на следующий шаг не должен зависеть от выхода данных с предыдущего шага

Это важно для того, чтобы злоумышленник не мог воспользоваться выходом дуплекса для того, чтобы его атаковать.
См. стр. 4 "1.3 Our Contribution" "Full-State Keyed Duplex With Built-In Multi-User Support" https://keccak.team/files/FSKD.pdf.

# Вывод

## Перестановка для объединения данных для вывода
После выполнения основного шага алгоритма, выполняется перестановка transpose128.

## Сам вывод
Если нужен вывод, то берутся первые 512-ть байтов состояния (младший байт по младшему адресу).
Перестановка выполняется вне зависимости от того, нужен вывод или нет.

# Основной шаг алгоритма

Основной шаг алгоритма состоит из применения 64-х раундов, состоящих из

0. Вычисление tweakVal
1. Поблочное преобразование keccak
2. Перестановка P1
3. Поблочное преобразование threeFish
4. Перестановка P2
5. Поблочное преобразование keccak
6. Перестановка P3
7. Поблочное преобразование threeFish
8. Переставнока P4.
На последнем раунде вместо P4 используется transpose387 (см. "Перестановка для объединения данных для вывода")

Для P1 используется rnd, кроме первых 8-ми раундов (transpose200)
Для P2 используется rnd, кроме первых 8-ми раундов (transpose128)
P3 - transpose200
P4 - transpose128

Один или оба из P1 или P2 может быть зависим от дополнительного независимого ключа. Предлагается, P1 как зависимый от независимого ключа. Независимый ключ - это ключ, который развязан с основным ключом с помощью алгоритма не меньшей стойкости, чем заданный, либо получен полностью независимо (то есть из количества энтропии не меньшего, чем стойкость основного ключа). Независимость ключа следует из того, что перестановки легче перехватывать по побочным каналам, чем простые ключевые вычисления.



Довычисление tweakVal происходит следующим образом.
Работа ведётся с младшим 8-мибайтовым словом tweak (старшее слово не затрагивается, в том числе, бит переноса не переносится).
Старшее 4-хбайтовое слово tweak складывается с номером раунда, домноженным на 2 (tweak не изменяется, запись производится в tweakVal).

Для каждого блока всё (8-мибайтовое) значение складывается с номером блока (начиная с нуля).

Таким образом, на каждый раунд и для каждого блока TweakVal разный.

На второе преобразование threeFish дополнительно старшее 4-хбайтовое слово tweak приращается на единицу.

## Поблочное преобразование threefish

Для блока i выполняется преобразование с ключом из блока j. Причём блок j берётся из первичного состояния. То есть блоки i и j - это блоки, значения которых берутся на момент начала поблочных операций.

Пусть N - количество блоков ThreeFish, которые умещаются во внутреннем состоянии.
Тогда j вычисляется как (i + N/2) mod N


# Тесты для проверок
Сжимаемость 7-zip
Частотный тест
	Определение количества нулей и единиц в блоках определённой длинны
	Максимальное отношение нулей и единиц и его распределение от блока к блоку
	Можно смотреть дисбаланс (+1 и -1 вместо 1 и 0; отношение дисбаланса к общему количеству должно уменьшаться при увеличении длины гаммы)
		https://habr.com/ru/company/securitycode/blog/237695/ Частотный побитовый тест
			Sobs = модуль дисбаланса делить на квадратный корень из количества битов (|S|/sqrt(n))
			erfc - функция эрфик для биномиального распределения
				(дополнительная функция ошибок: https://ru.wikipedia.org/wiki/Функция_ошибок )
			P = erfc(Sobs/sqrt(2)) должно быть более, чем 0,01.
		Тест на одинаковые идущие подряд биты (там же)
			Кстати, тест на знакоперемены можно ведь делать и к знакопеременам (правда, там будут худшие результаты)
		Спектральный тест (там же)
	Определение количества значений байтов
		Отношение максимума встреченных байтов к минимуму
		Распределение таких отношений (график)

Длина гаммы в режиме Overwrite с нулевым Tweak

