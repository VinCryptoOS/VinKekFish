Более точное описание реализаций см. в файле .\VinKekFish\GeneralOfDetails.md

# Незаконченные работы
Тест на длинну гаммы в режиме Overwrite
Проверить в тесте на то, что 1253539379 даёт длительный прирост (без приращения, с умножением).
Проверить по списку типовых ошибок

Сделать статистические тесты (см. в конце)

Сгенерировать таблицы transpose\* и просто задать их. Ну или алгоритм сделать.

Сделать реализации и протестировать их


# Алгоритм VinKekFish

Алгоритм имеет криптографическое состояние и Tweak (настройка для ThreeFish).
Построен аналогично keccak на основе конструкции Губка (Sponge) и на основе криптографических преобразований keccak и ThreeFish.

# Полный шаг губки
Перед первым шагом губки (или дуплекса) следует первичная инициализация
Она выполняется для губки один раз за всё время её работы.

Затем, для каждого шага следует
1. Вычисление нового Tweak для следующего шага
2. Непосредственный ввод данных
3. Перестановка для распределения впитанных данных
4. Основной шаг алгоритма (криптографические раунды)
5. Перестановка для объединения данных для вывода
6. Вывод данных

В случае необходимости, для повышения защищённости вывода от ошибок VinKekFish, вывод данных может быть пропущен через губку keccak.

# Использование губки
Примерное использование губки.

1. Ввод ключа (или открытого вектора инициализации)
2. Ввод открытого вектора инициализации (или ключа)
3. Ввод данных, вывод гаммы
4. Вывод гаммы и/или хеша

## Например, гаммирование с обратной связью по открытому тексту.

1. Ввод ключа, счётчик режимов 1. Инициализация Tweak любым значением. Шаг губки.
2. Ввод ОВИ, счётчик режимов 128. Шаг губки.
3. Вывод блока гаммы (и применение её к открытому тексту).
4. Ввод открытого текста. Счётчик режимов 0. Шаг губки.
5. Вывод блока гаммы
6. И так далее

Реальные схемы шифрования см. в файлах рядом: (пока таких файлов нет)

# Размер криптографического состояния

Размер состояния K*25600,
где K - нечётное натуральное число (1 или более; 1, 3, 5, 7 и т.д.).

Нечётность числа следует из того, что тогда общее количество блоков не делится на два. Допустим, для количества блоков 25 следует, что 0-ой блок соответствует 12-ому блоку. 12-ый блок соответствует 24-ому. 13-ый соответствует 0-ому.
Если бы блоков было чётное количество, то threefish применялся бы один раз в паре (0;12), а один раз к паре (12; 0). То есть было бы два зависимых между собой криптографических преобразования.

При нечётном K при преобразовании 0-ого блока ключ берётся из 12-ого блока. Но ключ из 0-ого блока берётся для преобразования 13-ого блока. То есть при многократном преобразовании, блоки будут сами собой перемешивать данные даже без таблиц перестановок и нет ярко выраженной зависимости между двумя блоками. Данные не будут зацикливаться только на одной паре блоков.

# Размер Tweak
Как определено в ThreeFish, размер Tweak составляет 16-ть байтов.

# Первичная инициализация

Первичная инициализация проходит один раз перед началом использования губки.
Дополнительная инициализация ключами или вектором инициализации происходит в шаге алгоритма (подаваемыми на вход губки или в начальный tweak)


## Tweak

Tweak инициализируется нулями либо вектором инициализации. В том числе, инициализация может происходить номером шифруемого блока при древовидном алгоритме шифрования.
Nonce лучше инициализировать непосредственно губку, чтобы обеспечить большую радномизацию. То есть Nonce вводить в губку для впитывания, а не в tweak.

Положено, что Tweak известен злоумышленнику. Если он не известен, то считается, что злоумышленник может его вычислить (алгоритм не защищает tweak).


## Криптграфическое состояние

### Сложная инициализация

Криптографическое состояние разделяется на строки по 16-ть байтов.
Таблица заполняющих чисел fillTable
0  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
3, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61

Далее, для i-ой строки каждого столбца происходит заполнение байта значением (i+1)\*(fillTable[N]), где N есть шаг алгоритма для данного столбца (начиная с нуля).
То есть для нулевой строки, копируется содержание fillTable, для первой строки - содержание fillTable копируется с умножением на два.

Например, для состояния из 32-х байтов состояние будет инициализировано следующими значениями
003 007 010 013 017 019 023 029 031 037 041 043 047 053 059 061 006 014 020 026 034 038 046 058 062 074 082 086 094 106 118 122

Таким образом обеспечивается заполнение всего начального состояния уникальными 16-ти байтовыми значениями для большей начальной рандомизации. Так как алгоритм поблочный, это поможет блокам сильнее отличаться друг от друга на первом шаге.

### Инициализация нулями
Вместо указанного выше алгоритма, допускается инициализировать начальное состояние нулями.


# Вычисление нового Tweak для следующего шага

Перед непосредственным вводом данных осуществляется приращение младшего 8-мибайтового слова на значение 1253539379 (это простое число, дано в десятичной системе исчисления). Младшее слово в массиве - первое (младший байт по младшему адресу).
Старшее 8-мибайтовое слово не изменяется (к нему осуществляется приращение при вводе данных). В том числе, бит переноса из младшего слова в старшее не переносится.

# Непосредственный ввод данных

Ввод данных осуществляется по блокам в 4096 битов (512-ть байтов).
Размер (в байтах) вводимого блока данных обозначим за r. r имеет размер 2 байта. r вводится в tweak и во внутреннее состояние. Ещё 1 байт (режим ввода) вводится во внутреннее состояние счётчика режимов.
Также в tweak могут вводится режимы работы губки (губка или overwrite).

## Подробное описание ввода размера и режима

После вычисления нового Tweak (см. выше), к старшему 8-мибайтному слову Tweak добавляется (арифметическим сложением) 2 байта размера вводимого блока (то есть добавляется число r).
Если ввод осуществляется в режиме overwrite, то к старшему байту старшего 8-мибайтового слова добавляется ещё 1 (то есть добавляется 0x0100_0000_0000_0000 к старшему 8-мибайтовому слову).
В режиме губки ничего не добавляется (только размер вводимого блока).
Кроме этого, в любом из режимов, к 3-ему (начиная с 1) по старшинству байту старшего 8-мибайтового слова добавляется значение счётчика режимов. Например, если счётчик режимов 3, то добавляется 0x0000_0300_0000_0000.

Ввод в криптографическое состояние может осуществляться с операцией побайтового xor (в режиме губки). Первые байты (младшие байты) идут по младшим адресам. Xor осуществляется непосредственно с первыми 512-тью байтами.
Также ввод может осуществляться простой перезаписью байтов (режим overwrite).

padding отсутствует, т.к. в tweak осуществляется ввод размера вводимого блока.
В режиме overwrite padding состоит в следующем.
Перезаписывается внешнее криптографическое состояние вводимым массивом байтов.
Перезапись каждого оставшегося байта (из внешнего состояния) осуществляется теми же значениями, как в начале использования губки.
Например, если осуществлён ввод числа 01 08 03, то первые 16-ть байтов будут следующими
001 008 003 013 017 019 023 029 031 037 041 043 047 053 059 061

Внутреннее состояние (ёмкость) при данной записи не изменяется (кроме следующих 3-х байтов).


Следующие два байта криптографического состояния получают xor (всегда именно xor вне зависимости от режима) с числом r (количеством вводимых байтов), и ещё следующий байт получает xor со счётчиком режимов.
Счётчик режимов может показывать, что именно происходит. Например, счётчик 1 может показать, что вводится вектор инициализации, счётчик 2 - что вводится ключ, счётчик 0 - что вводятся данные и т.п.
Режим overwrite в данном счётчике никак не обозначается.

Допускается обозначать режим overwrite или другие особенности ввода изменением неиспользуемых битов числа r или изменением счётчика режимов (если это не вводит неоднозначности при таком использовании).

Счётчик режимов может работать и в любых иных режимах или игнорироваться (быть нулём, то есть ни на что не влиять).

По умолчанию в счётчике режимов используется следующий алгоритм.
1, 2, 3, 4 ... - для блоков ключей
128, 129, 130, 131 - для блоков открытых векторов инициализации
0 - для остальных вводимых данных.


## Перестановка для распределения впитывания
Затем выполняется перестановка с помощью таблицы transpose200 (см. ниже)

## Если ввода не было
Если ввод был нулевого размера, то, из вышеописанного алгоритма следует следующее.

### В режиме губки
Если ввода не было, к tweak добавляется перерасчёт при начале шага +1253539379 к младшему слову.
В состояние вводится счётчик режима (если он не нулевой).
Перестановка transpose200 всё равно выполняется.

### В режиме overwrite
Если ввода не было, к tweak идёт приращение 0x0100_0000_0000_0000 к старшему 8-мибайтовому слову (и +1253539379 к младшему 8-мибайтовому слову).
Все 512-ть первых байтов криптографического состояния перезаписываются нулями.
Перестановка transpose200 всё равно выполняется.


### Ввод данных на следующий шаг не должен зависеть от выхода данных с предыдущего шага

Запрещено осуществлять ввод данных, которые зависят от полученных от губки данных с этого же шага.

Это важно для того, чтобы злоумышленник не мог воспользоваться выходом дуплекса для того, чтобы его атаковать.
См. стр. 4 "1.3 Our Contribution" "Full-State Keyed Duplex With Built-In Multi-User Support" https://keccak.team/files/FSKD.pdf.


### Ввод ключа

Ввод ключевой информации делается с помощью перезаписи, то есть в режиме overwrite. Это связано с тем, что перезапись информации более безопасна с точки зрения ПЭМИН, чем xor.

Ввод ключа до открытого вектора инициализации поставляет злоумышленнику данные для анализа данного ключа каждый раз при вводе. Однако, эти данные одни и те же, то есть прибавляют статистику только если оборудование для считывания неточное. В то же время, если оборудование точное - то оно считает ключ полностью либо считает множество данных, являющихся суммой обрабатываемых сигналов в каждый момент времени. За счёт этого, может быть получено довольно много данных.
На следующих шагах (при введении ОВИ) эти данные будут уже преобразовываться с различными данными.
Кроме этого, ввод открытого вектора инициализации возможен в режиме overwrite, что поможет выполнить необратимую операцию и создать неопределённость в отношении ключа для криптоаналитика.


Ввод ключа после открытого вектора инициализации поставляет злоумышленнику данные для анализа данного ключа, причём каждый раз разные. Однако, в обоих случаях (ввод перед/после), на втором этапе данные будут различны.
В целом, предпочтительнее вводить ОВИ (открытый вектор инициализации) ранее ключа. Так, по крайней мере, не будет ясно видной повторяющейся радиосигнатуры при начале шифрования одним и тем же ключом.


Ввод ключа на первом шаге (до любых преобразований) допускается путём инициализации криптографического состояния этим ключом (то есть простой записи ключа во внутрь состояния или дозаписи с xor), причём размер ключа в таком случае ограничивается лишь внутренним состоянием.
Допускается также одновременный ввод ключа и вектора инициализации тем же путём. Это аналогично инициализации "keyed duplex".
В таком случае разработчик должен обеспечить недвусмысленное отделение ключа от вектора инициализации, и всего этого от последующих данных. Например, путём фиксирования размера ключа и вектора инициализации. Необходимо также исключить одновременную запись (из разных потоков) в одну линию кеша при инициализации (если инициализацию выполняют несколько потоков), иначе одновременная запись в одну линию кеша повлечёт за собой инвалидацию кешей разных процессорных ядер.

После ввода ключевой информации и ОВИ, рекомендуется всегда делать холостой шаг алгоритма (без ввода данных), чтобы дополнительно отбить ключ. При этом, чтобы затруднить восстановление ключа, холостой шаг может быть сделан в режиме overwrite, то есть с перезаписью части данных нулями (это операция является необратимой и создаёт неопределённость в отношении ключа).


# Вывод данных

## Перестановка для объединения данных для вывода
После выполнения основного шага алгоритма, выполняется перестановка transpose128.

## Сам вывод
Если нужен вывод, то берутся первые 512-ть байтов состояния (младший байт по младшему адресу).
Перестановка выполняется вне зависимости от того, нужен вывод или нет.


# Основной шаг алгоритма

Основной шаг алгоритма состоит из применения 64-х раундов, состоящих из

0. Вычисление tweakVal
1. Поблочное преобразование keccak (точнее keccak-f)
2. Перестановка P1
3. Поблочное преобразование threeFish
4. Перестановка P2
5. Поблочное преобразование keccak
6. Перестановка P3
7. Поблочное преобразование threeFish (с довычисленным tweakVal)
8. Переставнока P4.
На последнем раунде вместо P4 используется transpose128 (см. "Перестановка для объединения данных для вывода")

После последнего раунда производится рандомизация. Применяется поблочная функция keccak-f (аналогично пунктам 1 и 5). После этого используется дополнительная перестановка transpose200. Так делается 4 раза, то есть всего: (keccak-f + transpose200) + (keccak-f + transpose200) + (keccak-f + transpose200) + (keccak-f + transpose200) .

Для P1 используется rnd, кроме первых 8-ми раундов (transpose200)
Для P2 используется rnd, кроме первых 8-ми раундов (transpose128)
P3 - transpose200
P4 - transpose128

Один или оба из P1 или P2 может быть зависим от дополнительного независимого ключа. Предлагается, P1 как зависимый от независимого ключа. Независимый ключ - это ключ, который развязан с основным ключом с помощью алгоритма не меньшей стойкости, чем заданный, либо получен полностью независимо (то есть из количества энтропии не меньшего, чем стойкость основного ключа). Независимость ключа следует из того, что перестановки легче перехватывать по побочным каналам, чем простые ключевые вычисления.



Довычисление tweakVal происходит следующим образом.
Работа ведётся с младшим 8-мибайтовым словом tweak (старшее слово не затрагивается, в том числе, бит переноса с младшего слова на старшее не переносится).
Старшее 4-хбайтовое слово tweak складывается с номером раунда, домноженным на 2 (tweak не изменяется, запись производится в tweakVal; tweak по прошествии раунда остаётся таким же, каким был до начала раунда).

Для каждого блока всё значение (8-мибайтовое младшее слово) складывается с номером блока (начиная с нуля). То есть для нулевого блока используется TweakVal, для первого блока: TweakVal + 1.

Таким образом, на каждый раунд и для каждого блока TweakVal разный.

На второе преобразование threeFish (пункт №7) дополнительно старшее 4-хбайтовое слово tweak приращается на единицу (tweakVal[0] += 0x1_0000_0000;).

## Поблочное преобразование threefish

Для блока i выполняется преобразование с ключом из блока j. Причём блок j берётся из первичного состояния. То есть блоки i и j - это блоки, значения которых берутся на момент начала поблочных операций.

Пусть N - количество блоков ThreeFish, которые умещаются во внутреннем состоянии.
Тогда j вычисляется как (i + N/2) mod N

# Защита после вывода

VinKekFish не проверен криптоаналитиками, поэтому, его стойкость находится под сомнением.
Чтобы уменьшить риски, можно защитить вывод. Однако это не обязательно.

1. Если используется генерация ключевой информации или ОВИ из основного ОВИ и основного ключа.
1.1. Для генерации 512 битных ключей и ОВИ

Вывод VinKekFish делится на блоки по 64-ре байта и пропускается через один keccak duplex. Дуплекс каждый шаг выдаёт 64-ре байта вывода.
Взаимозависимость таких ключей - 512 битов (VinKekFish эту стойкость не увеличивает).

Для усиления защиты, в keccak duplex может быть заранее введён дополнительный ключ.

1.2. Для генерации ключей и ОВИ, стойкостью 1024 бита. Полагаемся на предположение, что VinKekFish обеспечивает такую стойкость совместно с защитой.

Вывод VinKekFish делится на блоки по 128 байтов. Вводятся в keccak duplex с помощью xor с состоянием алгоритма (с rate, увеличенным до 128 байтов).
Дуплекс каждый шаг выдаёт по 512 битов (64 байта). Два блока VinKekFish по 128 байтов дадут после дуплекса два блока по 64 байта. В сумме получим 128 байтный блок.

2. Генерация гаммы, стойкостью 512 битов.

Аналогично 1.1. Вывод VinKekFish делится на блоки по 64-ре байта и пропускается через один keccak duplex. Дуплекс каждый шаг выдаёт 64-ре байта вывода.

3. Генерация гаммы, стойкостью 1024 бита. Полагаемся на предположение, что VinKekFish обеспечивает такую стойкость совместно с защитой.

3.1.
Аналогично 1.2. Вывод VinKekFish делится на блоки по 128 байтов. Вводятся в keccak duplex с помощью xor с состоянием алгоритма (с rate, увеличенным до 128 байтов).
Дуплекс каждый шаг выдаёт по 512 битов (64 байта). Два блока VinKekFish по 128 байтов дадут после дуплекса два блока по 64 байта. В сумме получим 128 байтный блок.

Как более медленный вариант, можно предложить вводить в keccak duplex большее количество блоков или уменьшать rate самого VinKekFish.


4. Универсальный ослабленный вариант. Каждый вывод VinKekFish полностью вводится в keccak duplex. На один полный вывод VinKekFish приходится 64 байта вывода. Эти 64 байта, правда, могут быть зависимы друг от друга только на 1024 бита стойкости. Но каждый блок будет развязан.
Очень медленный вариант.


## Рекомендация для дублирующих алгоритмов
С точки зрения оптимальной защиты, можно создать один (или два) keccak duplex и, после первого шага VinKekFish, проинициализировать его вводом из VinKekFish (200 байтов ввода, остальные байты выбрасываем либо ещё 200 берём для ОВИ во второй дуплекс). Далее keccak duplex может работать самостоятельно на создание ключей и ОВИ для дублирующего защитного шифрования. А VinKekFish будет использоваться независимо.


# Таблицы перестановок
transpose200
transpose128

Алгоритм выполнения перестановок в случае таблиц transpose200 и transpose128 состоит в том, чтобы транспонировать матрицу с размером строки 200 и 128 байтов. Под матрицей понимается массив криптографического состояния, который понимается как матрица, сохранённая по строкам подряд в массив.

Тест для проверки верности перестановки:
двойная перестановка transpose200+transpose200 или transpose128+transpose128 должна дать тот же массив, что был до этого.
Если в исходном массиве первые байты были 0, 1, 2, 3 и т.п., то после перестановки transpose200 первые байты должны быть 0, 200, 400, 600 и т.п. Байты с индексами, кратными 200 не должны измениться.


# Тесты для проверок
Сжимаемость 7-zip
Частотный тест
	Определение количества нулей и единиц в блоках определённой длинны
	Максимальное отношение нулей и единиц и его распределение от блока к блоку
	Можно смотреть дисбаланс (+1 и -1 вместо 1 и 0; отношение дисбаланса к общему количеству должно уменьшаться при увеличении длины гаммы)
		https://habr.com/ru/company/securitycode/blog/237695/ Частотный побитовый тест
			Sobs = модуль дисбаланса делить на квадратный корень из количества битов (|S|/sqrt(n))
			erfc - функция эрфик для биномиального распределения
				(дополнительная функция ошибок: https://ru.wikipedia.org/wiki/Функция_ошибок )
			P = erfc(Sobs/sqrt(2)) должно быть более, чем 0,01.
		Тест на одинаковые идущие подряд биты (там же)
			Кстати, тест на знакоперемены можно ведь делать и к знакопеременам (правда, там будут худшие результаты)
		Спектральный тест (там же)
	Определение количества значений байтов
		Отношение максимума встреченных байтов к минимуму
		Распределение таких отношений (график)

Длина гаммы в режиме Overwrite с нулевым Tweak

