Реализация VinKekFish K = 1. Подробное описание на естественном языке

Однопоточный эталон для K = 1

Реализация в
VinKekFish\cryptoprime\VinKekFish\VinKekFishBase.cs

# Общие слова

## Декларируемые криптографические свойства

	Алгоритм имеет параметр K = 1, то есть 25600 битов (3200 байтов) внутреннего состояния.
	Заявленная стойкость: 4096 битов.
	Номинальная стойкость: 4096 битов
	Стойкость без запасов: 8-10 кбитов.
	Размер ключа: от 4096 битов и более (рекомендуемое значение от 8192 до 16384 битов) (512 байтов, 1024 - 2048 байтов).
	Размер ОВИ: не более 9184 битов (1148 байтов)
	
	Длина выводимого за один шаг блока: 4096 битов, 512 байтов.
	Длина гаммы: при заявленной стойкости нормативная длина гаммы 2^4096 блоков, то есть 2^4105 байтов.
	
	Количество раундов: не менее 4 (4 рандомизирующих keccak-f в количестве раундов не учитывается).
	Рекомендуемое количество раундов: 64.
	
	Максимальное количество шифруемой информации на одном ключе (нагрузка на ключ):
	2^(20*(R-1)) байтов, но не более нормативной длины гаммы, где R - количество раундов алгоритма. При R = 4 можно зашифровать 2^60 байтов (примерно, 1 Петабайт).


## Вводимая информация

### Открытые векторы инициализации
	1. Основной ОВИ: вводится в VinKekFish во внутреннее состояние
		Размер ограничен 9184 битами (1148 байтов).
	2. Побочный ОВИ: вводится в Tweak алгоритма.
		Размер не более 16-ти байтов. Допускается не вводить.
		Допускается вводить в tweak алгоритма keccak-хеш от основного ОВИ или фрагмент основного ОВИ.

### Ключ
	Размер ключа не ограничен. Рекомендуется к вводу не менее 8192 бита ключевой информации.
	Вводится в VinKekFish во внутреннее состояние с помощью простого xor с внутренним состоянием,
	ключ при вводе конкатенируется с его размером (см. func VinKekFish.ВводКлюча).
	Таким образом возможно ввести до 16384 битов (2048 байтов) ключевой информации. Это константа MAX_SINGLE_KEY = 2048.

	Возможен ввод удлинённого ключа. В таком случае, ввод производится аналогично, но поблочно.

# Описание

# Алгоритмическое описание

	func VinKekFish.ВводКлюча
	ввод
		key:[512, *] массив байтов произвольной длины
			Ключ
		key.length: int
			Длина массива key (в байтах)
		StartIndexOfKey: int
			Начальный индекс, с которого начинается вводимая сейчас часть ключа
		OIV:[0, 1148] массив байтов произвольной длины
			Открытый вектор инициализации
		S:3200, массив байтов длины 3200
			Внутреннее состояние алгоритма. Должно быть проинициализированно начальными значениями
	
		Initiated:bool
			Если true, то состояние уже проинициализированно нестандартными значениями. Если false - то блок пустой (стандартно проинициализированный).
			
			Если false, то key записывается без xor, перезаписью.
			Обязательно использовать false тогда, когда записывается первый блок key
			Если записываются последующие блоки - рекомендуется использовать true.
	
		b, c: вспомогательные массивы для функции keccak-f
		tweak: массив из двух 8-мибайтовых целых чисел
			Используется в ThreeFish в преобразовании VinKekFish
		R: int
			Количество раундов для шифрования
		RE: int
			Количество раундов для шифрования при отбое (перезаписи нулями)
			Не может быть равно нулю при пользовательском вызове (иначе не произойдёт отбоя)
			Равно нулю при рекурсивном вызове

		State: структура для вывода информации о прогрессе алгоритма

	старт
		State.SetProgress(1, StartIndexOfKey, key.length)

		var len  = Минимум(MAX_SINGLE_KEY /* 2048 */, key.length - StartIndexOfKey)
		var len1 = младший байт от len
		var len2 = старший байт от len
		S[0] = S[0] xor len1
		S[1] = S[1] xor len2
		
		if Initiated
			for i = [0, len - 1] step 1
				S[i+2] = S[i+2] xor key[i + StartIndexOfKey]
		else
			for i = [0, len - 1] step 1
				S[i+2] = key[i + StartIndexOfKey]
	
		if OIV != null and OIV.length != 0
		
			if RE == 0
				ОШИБКА Рекурсивный вызов не принимает вектора инициализации

			var len1 = младший байт от OIV.length
			var len2 = старший байт от OIV.length
	
			S[2050] = S[2050] xor len1
			S[2051] = S[2051] xor len2
	
			for i = [0, OIV.length - 1] step 1
				S[i+2052] = OIV[i]

		// После ввода значений делаем шаг VinKekFish
		VinKekFish.Step(R, S, tweak, b, c)
		
		len = StartIndexOfKey + len

		if len < key.length
			VinKekFish.ВводКлюча
			(
				key: 			 key,
				key.length: 	 key.length,
				StartIndexOfKey: len,
				Initiated: 		 true,
				R:				 R,
				RE: 			 0,
				OIV: 			 null,

				S: S, b: b, c: c, tweak: tweak, State: State
			)

		if RE != 0
			State.SetProgress(2, 0)

			// Защита от обратного преобразования для вычисления ключа шифрования
			// После ввода всех блоков ключа, выполняется перезапись 4096 битов информации нулями
			// И делается шаг алгоритма
			VinKekFish.Input(data: null, length: 0, Overwrite: true)
			VinKekFish.Step(RE, S, tweak, b, c)
			
			State.SetProgress(2, 1)


	конец.
