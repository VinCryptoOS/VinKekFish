Реализация VinKekFish K = 1. Подробное описание на естественном языке

Однопоточный эталон для K = 1

Реализация в
VinKekFish\cryptoprime\VinKekFish\VinKekFishBase.cs

# Общие слова

## Декларируемые криптографические свойства

Алгоритм имеет параметр K = 1, то есть 25600 битов (3200 байтов) внутреннего состояния.

Заявленная стойкость: 4096 битов.

Номинальная стойкость: 4096 битов

Стойкость без запасов: 8-10 кбитов.

Размер ключа: от 4096 битов и более (рекомендуемое значение от 8192 до 16384 битов) (512 байтов, 1024 - 2048 байтов).

Размер ОВИ: не более 9184 битов (1148 байтов)

Дополнительный ключ: Не более 1600 битов (рекомендуется 512-1024 бита). Не должен быть зависим от основного ключа. Доп. ключ может вводится как дополнение к основному в VinKekFish (конкатенацией, но доп. ключ не спереди).


Длина выводимого/вводимого за один шаг блока: 4096 битов, 512 байтов. (BLOCK_SIZE=512)

Длина гаммы: при заявленной стойкости нормативная длина гаммы 2^4096 блоков, то есть 2^4105 байтов.


Количество раундов: не менее 4 (4 заключительных рандомизирующих keccak-f в количестве раундов не учитывается). MIN_ROUNDS = 4
Рекомендуемое количество раундов: 64. NORMAL_ROUNDS=64


Максимальное количество шифруемой информации на одном ключе (нагрузка на ключ):
2^(20*(R-1)) байтов, но не более нормативной длины гаммы, где R - количество раундов алгоритма. При R = 4 можно зашифровать 2^60 байтов (примерно, 1 Петабайт).


## Вводимая информация

### Открытые векторы инициализации
1. Основной ОВИ: вводится в VinKekFish во внутреннее состояние
	Размер ограничен 9184 битами (1148 байтов).
	
2. Побочный ОВИ: вводится в Tweak алгоритма.
	Размер не более 16-ти байтов. Допускается не вводить.
	Допускается вводить в tweak алгоритма keccak-хеш от основного ОВИ или фрагмент основного ОВИ.

### Ключ
Размер ключа не ограничен. Рекомендуется к вводу не менее 8192 бита ключевой информации.
Вводится в VinKekFish во внутреннее состояние с помощью простого xor с внутренним состоянием,
ключ при вводе конкатенируется с его размером (см. func VinKekFish.ВводКлюча).
Таким образом возможно ввести до 16384 битов (2048 байтов) ключевой информации. Это константа MAX_SINGLE_KEY = 2048.

Возможен ввод удлинённого ключа. В таком случае, ввод производится аналогично, но поблочно. Константа MAX_MULTIPLE_KEY = 512 = BLOCK_SIZE определяет максимально возможное количество байтов, вводимых за один раунд.

### Словесное описание ввода ключа и ОВИ
1. Ввести в первый два байта криптографического состояния младший и старший байты длины ключа в байтах.

2. Ввести ключ с помощью перезаписи внутреннего состояния, но не более 2048-ми байтов MAX_SINGLE_KEY

3. Сразу после 2+2048 байтов ввести младший и старший байты длины ОВИ (не более 1148 байтов)

4. Ввести ОВИ с помощью xor, но не более 1148 байтов

5. Сделать шаг шифрования (количество раундов может быть сокращено)

6. Если всё ещё остался ключ для ввода, ввести его с помощью xor аналогично пунктам 1 и 2. После каждого ввода делать шаг шифрования. Однако, константа MAX_SINGLE_KEY на последующих блоках заменяется на MAX_MULTIPLE_KEY.
Это связано с тем, что key, вводимый с помощью xor является более шумящей по ПЭМИН операцией. Поэтому, лучше вводить этот ключ более медленно. В целом, это не существенно (в реализации возможна замена MAX_MULTIPLE_KEY = MAX_SINGLE_KEY).
При вводе дополнительных порций ключа шифрование может быть с минимальным количеством раундов (MIN_ROUNDS).

7. После полного окончания ввода делается ввод нулевого количества информации в режиме OVERWRITE. Это означает, что BLOCK_SIZE байтов будут перезаписаны нулями. После этого исполняется шаг алгоритма. Это делается для внесения необратимости (перезапись нулями - точно необратимая операция), чтобы усложнить получение ключа, даже если данные будут расшифрованы.
Количество раундов здесь должно быть, по возможности, как можно больше (рекомендуется NORMAL_ROUNDS).

### Дополнительный ключ
Дополнительный ключ используется для инициализации таблиц перестановок и вводится перед вводом основного ключа.
При вводе дополнительного ключа используется дуплекс keccak.
Ключ вводится в дуплекс keccak в режиме перезаписи внутреннего состояния keccak.

После этого, дуплекс keccak используется для генерации таблиц перестановок.
Вывод от генерирующего keccak duplex также может быть использован для дополнительной инициализации дублирующего keccak duplex.


# Описание

# Алгоритмическое описание

	func VinKekFish.ВводКлюча
	ввод
		key:[512, *] массив байтов произвольной длины
			Ключ
		key.length: int
			Длина массива key (в байтах)
		StartIndexOfKey: int
			Начальный индекс, с которого начинается вводимая сейчас часть ключа
		OIV:[0, 1148] массив байтов произвольной длины
			Открытый вектор инициализации
		S:3200, массив байтов длины 3200
			Внутреннее состояние алгоритма. Должно быть проинициализированно начальными значениями
	
		Initiated:bool
			Если true, то состояние уже проинициализированно нестандартными значениями. Если false - то блок пустой (стандартно проинициализированный).
			
			Если false, то key записывается без xor, перезаписью.
			Обязательно использовать false тогда, когда записывается первый блок key
			Если записываются последующие блоки - рекомендуется использовать true.

		SecondKey: bool
			true - если первый ввод ключевой информации
			false - если повторный ввод
			В алгоритме предполагается, что Initiated == SecondKey

		b, c: вспомогательные массивы для функции keccak-f
		tweak: массив из двух 8-мибайтовых целых чисел
			Используется в ThreeFish в преобразовании VinKekFish
		R: int
			Количество раундов для шифрования первого блока ключа (MAX_SINGLE_KEY байтов)
		RE: int
			Количество раундов для шифрования при отбое (перезаписи нулями)
			Не может быть равно нулю при пользовательском вызове (иначе не произойдёт отбоя)
			Равно нулю при рекурсивном вызове
		RM: int
			Количество раундов шифрования при вводе дополнительных частей ключа (более MAX_SINGLE_KEY байтов)

		State: структура для вывода информации о прогрессе алгоритма

	старт
		if OVI != null and OIV.length > 1148
			ОШИБКА! Вектор инициализации не может быть более 1148 байтов
			
		if SecondKey || (OIV != null and OIV.length > 0)
			ОШИБКА! ОВИ принимается только на первом шаге шифрования

		if RE != 0 and SecondKey
			ОШИБКА! ОВИ принимается только на первом шаге шифрования. RE должен быть равен нулю

		State.SetProgress(1, StartIndexOfKey, key.length)

		var max_key = if SecondKey then MAX_MULTIPLE_KEY else MAX_SINGLE_KEY

		var len  = Минимум(max_key, key.length - StartIndexOfKey)
		var len1 = младший байт от len
		var len2 = старший байт от len
		S[0] = S[0] xor len1
		S[1] = S[1] xor len2
		
		if Initiated
			for i = [0, len - 1] step 1
				S[i+2] = S[i+2] xor key[i + StartIndexOfKey]
		else
			for i = [0, len - 1] step 1
				S[i+2] = key[i + StartIndexOfKey]
	
		if OIV != null and OIV.length != 0
		
			if RE == 0
				ОШИБКА Рекурсивный вызов не принимает вектора инициализации

			var len1 = младший байт от OIV.length
			var len2 = старший байт от OIV.length
	
			S[2050] = S[2050] xor len1
			S[2051] = S[2051] xor len2
	
			for i = [0, OIV.length - 1] step 1
				S[i+2052] = OIV[i]

		// После ввода значений делаем шаг VinKekFish
		VinKekFish.Step(R, S, tweak, b, c)

		len = StartIndexOfKey + len

		if len < key.length
			VinKekFish.ВводКлюча
			(
				key: 			 key,
				key.length: 	 key.length,
				StartIndexOfKey: len,
				Initiated: 		 true,			// !
				SecondKey:		 true,			// !
				R:				 RM,			// !
				RE: 			 0,				// !
				RM:				 RM,
				OIV: 			 null,			// !

				S: S, b: b, c: c, tweak: tweak, State: State
			)

		// Завершающая стадия ввода всех частей ключа
		if !SecondKey
			State.SetProgress(2, 0)

			// Защита от обратного преобразования для вычисления ключа шифрования
			// После ввода всех блоков ключа, выполняется перезапись 4096 битов информации нулями
			// И делается шаг алгоритма
			VinKekFish.Input(data: null, length: 0, Overwrite: true)
			VinKekFish.Step(RE, S, tweak, b, c)
			
			State.SetProgress(2, 1)


	конец.
