Интуитивно размышляем насчёт алгоритма с повышенной длиной ключа

1. Чтобы построить расширенный алгоритм, желательно обеспечить
	Многопоточность
	Возможность блоков эффективно обмениваться друг с другом информацией
	Некоторая доп. стойкость
	Вопрос насчёт использования большого объёма памяти со случайным доступом остаётся открытым



Обмен блоков информацией
	Интуитивно, каждый блок должен обмениваться с каждым, то есть квадратичная сложность.
	Если каждый блок представить алгоритмом keccak, то можно было бы сказать, что keccak должен передать входной блок каждому другому блоку, а тот должен этот блок принять
	Пусть у нас везде нули и только на одном блоке установлен один бит. Этот бит должен распространиться, причём дав разные фрагменты общего состояния. Это касается даже случаев, когда мы явно обеспечиваем отсутствие такой ситуации (где всё - нули)
	Как знать, что этот бит не будет "поглощён" другими битами. С одной стороны, бит, наверное, будет и через многократные преобразования влиять на каждый бит результата. С другой стороны, при многократных преобразованиях можно интуитивно считать, что биты "поглощаются". Так, если взять совсем простой хеш и многократно его прохешировать, когда-то он случайно придёт к первоначальному состоянию. Правда, когда именно - это тоже случайность. Длина этой цепочки - тоже информация.
	Если бит влияет на другой бит с вероятностью 1/2, то это значит, вероятность того, что этот бит не повлиял ни на какой другой составляет 1/2^n. То есть для n битов будет потеряно n/2^n битов. Для 16 битов это будет 16/2^16=1/4096. Для 32 битов это будет 32/2^32=1/134217728.
	Приблизительно, можно считать, что для L шагов преобразований, будет потеряно L*n/2^n.
	Таким образом, L*n должно быть существенно меньше, чем 2^n. Оно всегда так.
	Для входа в 2*n битов можно считать, что биты на выходе n битов представлены с вероятностью 1/2.
	Значит, для n преобразований вероятность будет 1/2^n, то есть для уверенного распространения бита нужно будет повторить цепочку операций 2^n раз (каждый раз с новой подачей этого бита в цепочку операций).
	Либо подать в каждый из n блоков бит данных напрямую один раз.
	
Скрытые блоки
	Теоретически, анализ информации можно затруднить.
	Предположим, что обращение данных для хеша возможно и идёт длительно, но приемлемо. Для обращения внутреннего состояния нам нужно, допустим, 3 хеша (состояние keccak 200 байтов, за три хеша мы получим 196).
	Если мы возьмём два блока, 1 -> 2 -> 1 -> выход, то чтобы обратить данные, то у нас получается внутреннее состояние уже двойное (такая набла: спуск-подъём). Чтобы обратить выход нам нужно с блока 1 получить два хеша подряд. Но хеши мы получаем не подряд, то есть уже сложность.
	Таким образом, нам нужно всегда при генерации не просто генерировать хеш, но либо использовать скрытый блок 1 -> 2 -> 1 -> выход, либо использовать водопад 1 -> 2 -> выход.
	Теоретически, можно представить себе 1 -> 2 + (второй вход -> 2) -> 1 -> выход.
	Сначала спускаем информацию вниз, потом она назад всплывает вверх, но с дополнительной рандомизацией.
	
	
Перестановки
	Во внутреннем блоке могут быть перестановки байтов.
	То есть мы доверяем исходному преобразованию, но делаем перестановки байтов. Таким образом, мы доставляем все байты во все блоки.
	Возможно, это означает, что у нас должно быть два внутренних состояния: одно управляет перемешиванием, а второе перемешивается. А потом они меняются местами.
	Проблема в том, что перемешивать надо много, а состояния мало.
	Либо надо брать хеш от состояния и перемешивать от этого хеша.
	Либо от самого состояния всё брать, что нужно
	
	Перестановки могут быть уязвимы к ПЭМИН, ведь перестановка данных не из кеша может выглядеть не очень: дополнительный всплеск вычислений на времена порядка 1/72 периода, то есть для 2,8 ГГц это 38 МГц.
	Впрочем, если считать кеш 32 кб, то это уже много для 16 кб состояния. Может и ничего

	Как делать псевдопреобразование тройками?
	M = 
		1 3 5
		5 1 3
		3 5 1

	// Обратная матрица https://ru.onlinemschool.com/math/assistance/matrix/inverse/
	всё делить на 54
	-7 11  2
	 2 -7 11
	11  2 -7

	При переполнении нужно добавлять, в идеале, переполненные результаты куда-нибудь
	Можно перемешивать семёрками байтов. Но это проблема. Делить на 7 нацело внутреннее состояние не получится.
	В любом случае, теряются биты, похоже что. То есть без гарантий

	Либо, всё-таки, пользоваться классическим преобразованием адамара

	256*8 байтов внутреннего состояния, то есть 2048 байтов, то есть 16384 битов
	Можно переставлять тройками, смотря каждый байт. Всего получится 682 перестановки элементов по 8-мь байтов
	8-мибайтовые слова можно ещё и ротировать дополнительно. Например, если они ставятся на индекс i, то их можно ротировать вправо на (i % 31)
	
	Сдвиг переставляемого слова ещё и может быть в пределах 8-ми байтов. То есть можно брать какую-то константу, например, сумму от переставляемых слов, и брать из неё три бита для сдвига.


	Из-за того, что кеширование может повлиять на атаки по побочным каналам, возможно, не стоит вообще пользоваться какими-либо перестановками, зависящими от ключа. То есть перестановки должны быть только общие для всех ключей, а потом должен применяться обычный keccak и treefish.
	См. спецификацию Skein 
	
	1. После каждого раунда шифрования можно делать перемешивание по таблицам. Таблицы чередовать с разными способами получения: перемешивание предсказуемым алгоритмом, перемешивание заранее сделанным псевдослучайным алгоритмом, перемешивание на основе tweak (синхропосылки или "настройки"). Но tweak при подготовке может быть опасен для тайминг-атак.
		При перемешивании можно перемешивать дважды.
			Первое перемешивание: по 8-байтовым словам со сдвигом.
			Второе перемешивание: по байтам со сдвигом.
			Возможно, третье перемешивание: по два индекса на их местах: преобразование адамара. А может, нефиг баловаться?
			При перемешивании также может накладываться битовая маска xor, однако это большой вопрос (маска может вычисляться keccak)
	2. Применение полнораундового keccak
	3. Применение полнораундового treefish. При этом это тоже таблица: индекс для tweak, индекс для key (в старом состоянии, результат записывается в новое состояние; или, всё-таки делается всё на новом состоянии?).
	4. Снова перемешивание. В конце - взять каждый четвёртый элемент внутреннего состояния
	5. Возможно, для каждого блока по 64-байта поставить его в свой keccak для дополнительной защиты


